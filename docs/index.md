# HarpEngine
Welcome to the documentation! On this home page, I will provide a basic introduction on the structure of HarpEngine. From there, you should be able to jump around other pages to find what you need.

### Why use HarpEngine?
> "Um, actually. It's a framework."

Yes, it is a framework. Why is it a framework and what does that mean?

The reason HarpEngine exists is for quickly prototyping games with dedicated 2D and 3D modes as well as immediate-mode. That is, without the bloat of a game engine. It is not a game engine in the traditional since because it does not have a built-in UI or a proprietary runtime. As a framework, your scripts and the backend live on the same level. But, It's called HarpEngine because engine is a fun word, and the developer Harper is too stubborn to change it.

[Love2D](https://love2d.org/) and [Processing](https://processing.org/) come close to this sort of project that I have always dreamed of, but both fall a little short. Lua (which Love2D uses) has trouble with scaleability, and Java (which Processing uses) is not the worst but Processing is not built for shipable projects. Then, there's [Raylib](https://www.raylib.com/). All of the features, but you'll have to program a game engine if you want to ship something. So HarpEngine was created.

# Installation
This is the easiest part. In Visual Studio, either install the [template](https://github.com/harper-rhett/harp-engine-template) or create a new console application and install the [NuGet package](https://www.nuget.org/packages/HarpEngine).

# Structure
HarpEngine is broken up into layers, and it somewhat works like this:

```
Engine
├─ Windowing
└─ Game
	├─ Update Loop
	├─ Draw Loop
	└─ Scenes
		└─ Entities
```

# Engine
In your program.cs file, you will initialize an engine with settings and attach your game. Nothing special about this, it just prepares the window and starts the update loop.

```csharp
using HarpEngine;

EngineSettings settings = new()
{
	// window size, window name, and game size go here
};
Engine.Initialize(settings);
MyGame myGame = new();
Engine.Start(myGame);
```

### Game
Now we're getting somewhere. Create a class and inherit it from `Game`. This is where you will be fed the update and draw loops generated by HarpEngine.

```csharp
internal class MyGame : Game
{
	public MyGame()
	{

	}

	public override void Update(float frameTime)
	{
		
	}

	public override void Draw()
	{
		
	}
}
```

At this point, you could go ahead and start programming your game. But then you would miss out on the bulk of the engine's tools. Scenes and entities is where most of the heavy lifting is handled for you.

# Scenes
A scene is essentially a collection of entities with several features useful for development:
- Layering: Modify the order entities are updated and drawn in.
- Registry: High performance look up of entities.
- Timing: Simple pausing and timer/easer creation.

And, your game class is where scenes will be managed. One scene is great for prototyping. Just create a new scene from the base class, and then you can add entities to it with ease.

```csharp
internal class MyGame : Game
{
	Scene scene = new();

	public MyGame()
	{
		new CustomEntity(scene); // a new CustomEntity object is added to the scene
	}

	public override void Update(float frameTime)
	{
		scene.Update(frameTime);
	}

	public override void Draw()
	{
		scene.Draw();
	}
}
```

But of course, one scene will not be enough for a full game. At minimum, a main menu and game scene will probably be necessary. This is where you would inherit from `Scene`.

```csharp
internal class MenuScene : Scene
{
	public MenuScene()
	{
		new MenuManager(this);
	}
}
```

```csharp
internal class GameScene : Scene
{
	public GameScene()
	{
		new GameManager(this); // GameManager inherits from Entity
		for (int enemyIndex = 0; enemyIndex < enemyCount; enemyIndex++)
		{
			new Enemy(this); // Enemy inherits from Entity
		}
	}
}
```

Custom scenes are only useful for initializing a scene state. They do not have public update and draw loops, because those are handled internally for handling the entities. It may be convenient for scenes to have their own public facing loops, but ultimately it was decided that managers would make more sense. Maybe this will change in the future.

So, now your game class may look like this:

```csharp
internal class MyGame : Game
{
	public static HelloGame Instance;
	private Scene activeScene;

	public HelloGame()
	{
		Instance = this;
		activeScene = new MenuScene();
	}

	public override void Update(float frameTime)
	{
		activeScene.Update(frameTime);
	}

	public override void Draw()
	{
		activeScene.Draw();
	}

	public void Start() // called from MenuManager using MyGame.Instance.Start()
	{
		activeScene = new GameScene();
	}
}
```

Multiple scenes can also be run at once, drawing over each other. This is useful for pause menus.

# Entities
This is where the magic happens. Game objects, actors, nodes. It doesn't matter what you call them. HarpEngine knows them as entities. An entity could be a hero or an enemy. A manager or a utility. In fact, several of the engine's tools such as `ParticleEngine2D` and `Easer` are built on this class. In entity scripts is where most of your game's logic will happen.

Here's an example of an entity that is simply a polygon:

```csharp
public class Polygon : Entity
{
	public Transform2D Transform = new();
	public int SideCount;
	public float Radius;
	public Color Color;

	public Polygon(Scene scene, float radius, int sideCount, Color color) : base(scene)
	{
		Radius = radius;
		SideCount = sideCount;
		Color = color;
	}

	public override void Draw()
	{
		Primitives.DrawPolygon(Transform.WorldPosition, SideCount, Radius, Transform.WorldRotation, Color);
	}
}
```

# Learn More
That about covers the basics. Not too bad, right? From here I would recommend either installing the [template](https://github.com/harper-rhett/harp-engine-template) or checking out the [examples](https://github.com/harper-rhett/harp-engine-examples). And of course jumping around the documentation or reading the [source code](https://github.com/harper-rhett/harp-engine/tree/main/HarpEngine).